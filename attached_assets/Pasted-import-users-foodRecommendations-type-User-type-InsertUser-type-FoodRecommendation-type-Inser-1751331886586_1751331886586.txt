import { users, foodRecommendations, type User, type InsertUser, type FoodRecommendation, type InsertFoodRecommendation, type RecommendationRequest } from "@shared/schema";

export interface IStorage {
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  getFoodRecommendation(request: RecommendationRequest): Promise<FoodRecommendation>;
  getAlternativeRecommendations(category: string, excludeId?: number): Promise<FoodRecommendation[]>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private foodRecommendations: FoodRecommendation[] = [];
  currentId: number;

  constructor() {
    this.users = new Map();
    this.currentId = 1;
    this.initializeFoodData();
  }

  private initializeFoodData() {
    // Helper function to create authentic Korean food imageUrls
    const createKoreanFoodImages = (dishName: string) => {
      const koreanFoodImages: { [key: string]: string[] } = {
        "ÍπÄÏπòÏ∞åÍ∞ú": [
          "https://www.10000recipe.com/recipe/6875776"
        ],
        "ÎπÑÎπîÎ∞•": [
          "https://www.flickr.com/photos/28604754@N00/5896614484"
        ],
        "Î∂àÍ≥†Í∏∞": [
          "https://seasonedbyjin.com/korean-beef-bulgogi-recipe/"
        ],
        "Îñ°Î≥∂Ïù¥": [
          "https://wtable.co.kr/recipes/mbgSa5ekLhRQgPUCPxTCCxbt"
        ]
      };
      return koreanFoodImages[dishName] || ["https://example.com/default-food.jpg"];
    };

    const baseItems = [
      {
        id: 1,
        name: "ÍπÄÏπòÏ∞åÍ∞ú",
        category: "korean",
        priceRange: "budget",
        spiceLevel: "medium",
        price: 8000,
        description: "ÏñºÌÅ∞ÌïòÍ≥† ÏãúÏõêÌïú ÍπÄÏπòÏ∞åÍ∞úÎ°ú ÏÜçÏùÑ Ï±ÑÏõåÎ≥¥ÏÑ∏Ïöî! Îî∞ÎúªÌïú Íµ≠Î¨ºÏù¥ Î™∏ÏùÑ Îç∞ÏõåÏ§Ñ Í±∞ÏòàÏöî.",
        tags: ["üå∂Ô∏èüå∂Ô∏è Î≥¥ÌÜµÎßõ", "üçö Î∞• Ìè¨Ìï®", "ü•¨ Î∞òÏ∞¨ 3Ï¢Ö"]
      },
      {
        id: 2,
        name: "ÎπÑÎπîÎ∞•",
        category: "korean",
        priceRange: "budget",
        spiceLevel: "medium",
        price: 8500,
        description: "Ïã†ÏÑ†Ìïú ÎÇòÎ¨ºÍ≥º Í≥†Ï∂îÏû•ÏúºÎ°ú Î≤ÑÎ¨¥Î¶∞ Í±¥Í∞ïÌïú ÎπÑÎπîÎ∞•Ïù¥ÏóêÏöî.",
        tags: ["üå∂Ô∏èüå∂Ô∏è Î≥¥ÌÜµÎßõ", "ü•¨ ÎÇòÎ¨º Îì¨Îøç", "ü•ö Í≥ÑÎûÄÌõÑÎùºÏù¥"]
      },
      {
        id: 3,
        name: "Î∂àÍ≥†Í∏∞",
        category: "korean",
        priceRange: "moderate",
        spiceLevel: "mild",
        price: 12000,
        description: "Îã¨ÏΩ§ÌïòÍ≥† Î∂ÄÎìúÎü¨Ïö¥ Î∂àÍ≥†Í∏∞Î°ú ÌäπÎ≥ÑÌïú Ï†êÏã¨ÏùÑ ÎßåÎì§Ïñ¥Î≥¥ÏÑ∏Ïöî.",
        tags: ["ü•õ ÏàúÌïúÎßõ", "ü•© ÌîÑÎ¶¨ÎØ∏ÏóÑ Í≥†Í∏∞", "üçö Î∞• Ìè¨Ìï®"]
      },
      {
        id: 4,
        name: "Îñ°Î≥∂Ïù¥",
        category: "street",
        priceRange: "budget",
        spiceLevel: "medium",
        price: 4000,
        description: "Îß§ÏΩ§Îã¨ÏΩ§Ìïú Îñ°Î≥∂Ïù¥Î°ú Í∞ÑÎã®ÌïòÍ≤å Î∞∞Î•º Ï±ÑÏõåÎ≥¥ÏÑ∏Ïöî.",
        tags: ["üå∂Ô∏èüå∂Ô∏è Î≥¥ÌÜµÎßõ", "üç¢ Ïñ¥Î¨µ Ìè¨Ìï®", "ü•ö Í≥ÑÎûÄ Ï∂îÍ∞Ä Í∞ÄÎä•"]
      }
    ];

    this.foodRecommendations = baseItems.map(item => ({
      ...item,
      imageUrls: createKoreanFoodImages(item.name),
      imageUrl: createKoreanFoodImages(item.name)[0]  // ÎåÄÌëú Ïù¥ÎØ∏ÏßÄ ÏÑ§Ï†ï
    }));
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.currentId++;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }

  async getFoodRecommendation(request: RecommendationRequest): Promise<FoodRecommendation> {
    const exactMatches = this.foodRecommendations.filter(food => 
      food.category === request.category &&
      food.priceRange === request.priceRange &&
      food.spiceLevel === request.spiceLevel
    );

    if (exactMatches.length > 0) {
      return exactMatches[Math.floor(Math.random() * exactMatches.length)];
    }

    const categoryPriceMatches = this.foodRecommendations.filter(food => 
      food.category === request.category &&
      food.priceRange === request.priceRange
    );

    if (categoryPriceMatches.length > 0) {
      return categoryPriceMatches[Math.floor(Math.random() * categoryPriceMatches.length)];
    }

    const categoryMatches = this.foodRecommendations.filter(food => 
      food.category === request.category
    );

    if (categoryMatches.length > 0) {
      return categoryMatches[Math.floor(Math.random() * categoryMatches.length)];
    }

    return this.foodRecommendations[Math.floor(Math.random() * this.foodRecommendations.length)];
  }

  async getAlternativeRecommendations(category: string, excludeId?: number): Promise<FoodRecommendation[]> {
    const alternatives = this.foodRecommendations
      .filter(food => food.category === category && food.id !== excludeId);

    const shuffled = alternatives.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, 3);
  }
}

export const storage = new MemStorage();
